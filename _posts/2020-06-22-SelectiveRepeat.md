---
toc: true
toc_sticky: true
categories:
  - Network
title: 네트워크 - Selective Repeat의 동작과 마주하는 딜레마와 극복
tags: [Network]
excerpt: "데이터 통신상의 Selective Repeat 기법의 동작과 마주하는 딜레마와 극복하는 방법을 정리합니다."
---

# Selective Repeat

![image](https://user-images.githubusercontent.com/57826388/87137994-b4302500-c2d8-11ea-8ec8-4ae6c0e07e10.png)

## 기본 동작

위의 그림은 `파이프라이닝`이 적용된 TCP 전송 프로토콜에서의 데이터가 어떻게 전송되는지를 보여줍니다. 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송하는 것을 보면 파이프라이닝 방식인지, 전송 후 대기 방식인지 알 수 있습니다. 또한 `pkt2`가 재전송 될 때, 이후의 모든 패킷을 재전송하지 않는 것을 보아 `Selective Repeat` 방식임을 알 수 있습니다.

그림을 자세히 보면, `pkt0`과 `pkt1`은 정상적으로 전송되어 수신자 측에서 `ACK0`, `ACK1`으로 응답을 한 것을 알 수 있습니다. 동시에 이 패킷들은 상위계층으로 전달됩니다. 하지만 `pkt2`는 패킷 로스가 발생했음을 알 수 있습니다. 따라서 수신자가 순서에 맞는 패킷 받지 못하여 `pkt2`에 해당하는 윈도우 베이스는 다음 패킷으로 옮겨지지 못합니다. 그 후, 수신자가 다음에 받은 `pkt3`은 순서에 맞지 않기 때문에 우선 이를 버퍼에 저장하고 `ACK3`으로 응답합니다.

이후, 송신자는 수신자의 ACK을 받게 됩니다. 따라서 송신자의 윈도우 베이스는 다음 패킷으로 이동하게 됩니다. 그리고 다음 `pkt4`, `pkt5`를 전송합니다. 하지만 `ACK3`을 받았을 때에는 아직 `ACK2`가 도착하지 못했기 때문에 버퍼에 기록합니다. 마찬가지로 윈도우 베이스는 다음 패킷으로 옮겨지지 못합니다.

이제 수신자에서 `pkt4`와 `pkt5`를 받게 되어 ACK을 보내지만, 여전히 `pkt2`를 받지 못했기 때문에 버퍼에 기록하고 윈도우 베이스는 옮겨지지 못합니다.

마침내 송신자 측에서 `pkt2` 타임아웃이 발생하고 이를 재전송합니다. 동시에 `ACK4`와 `ACK5`는 버퍼에 기록합니다.

수신자는 `pkt2`를 무사히 받으면, `pkt2`에 대한 ACK을 전송하고 `pkt2`와 버퍼에 저장된 값들이 모두 상위계층으로 전달됩니다. 그리고 수신자 윈도우에 있는 패킷 수만큼의 크기로 윈도우 베이스는 다음 패킷으로 옮겨집니다.

<br>

## ACK2를 수신한 시점

송신자는 마침내 `ACK2`를 수신하게 됩니다. 윈도우에 있는 모든 패킷에 대한 ACK을 무사히 받았기 때문에 송신자는 윈도우 베이스를 패킷의 수만큼의 크기로 다음 패킷으로 옮기게 됩니다. 여기서 순서 번호는 순환방식이기 때문에 순서 번호 허용치의 최댓값이 될 경우, 다시 순서 번호의 최솟값부터 윈도우가 이어지게 됩니다.

이후, 송신자와 수신자의 윈도우가 처음 상태처럼 갱신되었으므로, 송신자와 수신자는 다시 데이터 통신이 가능합니다. 송신자는 맨 처음 데이터를 전송할 때와 마찬가지로 전송할 데이터가 있을 경우, 변경된 윈도우의 패킷을 순차적으로 수신자에게 전송할 수 있습니다. 이러한 과정이 반복되어 파이프라이닝 Selective Repeat 방식의 TCP의 신뢰성 있는 통신이 이루어지게 됩니다. 

이를 그림으로 보면 다음과 같습니다.

![image](https://user-images.githubusercontent.com/57826388/87138038-cf9b3000-c2d8-11ea-8f68-4b4893fbb3ea.png)

위에서 설명했듯이, pkt2에 대한 ACK이 수신되어 그 동안 버퍼에 저장 되어있던 패킷에 대한 ACK들을 응답합니다. 이와 동시에 윈도우 베이스는 그 만큼 옮겨지게 됩니다. 송신자의 윈도우와 수신자의 윈도우 베이스가 새로운 패킷을 가지며 송신자와 수신자의 베이스는 서로 같은 값을 가지게 됩니다.

<br>

# Selective Repeat 딜레마

## SR 딜레마 상황

### **한정된 패킷 순서번호를 사용할 때 패킷 손실의 경우**

![image](https://user-images.githubusercontent.com/57826388/87138257-1ee16080-c2d9-11ea-9f3b-a83133cc87ff.png)

첫 번째 상황으로는 한정된 패킷 순서번호를 사용할 때 패킷이 손실이 발생하는 경우입니다. 위의 사진을 보면 알 수 있듯이 윈도우 사이즈는 3이고 순서번호가 0, 1, 2, 3을 가지고 있습니다. 처음 `pkt0`, `pkt1`, `pkt2`는 정상적으로 전송되었습니다. 이후 ACK을 받고 윈도우를 앞으로 이동시킨 다음 순서번호를 지닌 패킷인 `pkt3`부터 전송이 이루어집니다.

`Pkt1`에 대한 ACK을 받게 되면 그 다음 순서번호를 지닌 `pkt0`이 전송됩니다. 그 때, `pkt3`이 전송되지 못할 경우 수신자는 자신의 `pkt0`에 대한 ACK이 제대로 송신되었는지 알지 못합니다. 따라서 그 상태에서 `pkt0`을 수신하게 되면 이 패킷이 새로 전송된 건지, 재전송된 건지 알 수 있는 방법이 없게 되어 문제가 발생합니다.

<br>

### **한정된 패킷 순서번호를 사용할 때 ACK 손실의 경우**

![image](https://user-images.githubusercontent.com/57826388/87138276-23a61480-c2d9-11ea-827f-eaba1ba67e4f.png)

두 번째 상황으로는 한정된 패킷 순서번호를 사용할 때 ACK 손실이 발생하는 경우입니다. 위의 사진을 보면 알 수 있듯이 순서번호의 허용치와 윈도우 사이즈는 이전에 설명한 경우와 같습니다. 차이점은 수신자가 송신자에게 보내는 ACK 손실이 발생한다는 점입니다.

수신자의 ACK이 송신자에게 전달되지 못하면 송신자는 ACK을 받지못한 패킷을 재전송하게 됩니다. 하지만 수신자는 이미 송신자의 패킷을 받아 윈도우를 옮긴 상태입니다. 이럴 경우, 수신자는 현재 윈도우를 보았을 때, 재전송되는 패킷인지 새로 전송되는 패킷인지 알지 못하게 되어 문제가 발생합니다.

<br>

## 해결 방법

위에서 설명한 두 가지 딜레마 상황을 보면 공통점이 있습니다. 바로 한정된 순서번호를 사용한다는 점입니다. 즉, 한정된 순서번호의 허용치가 윈도우 사이즈보다 크게 많지 않다는 점입니다. 따라서 이 문제를 해결하기위한 방법은 윈도우 사이즈보다 순서번호의 허용치를 크게 늘리는 것입니다. 

위의 시나리오에서 순서번호 허용치는 4입니다. 윈도우 사이즈는 유지하고 이것을 5로 늘려봅니다. 수신자의 ACK이 발생하거나 패킷 손실이 발생하는 모든 경우를 고려해보았을 때 여전히 딜레마는 유지됩니다.

이번에는 순서번호 허용치를 6으로 늘리고 패킷 손실 시나리오를 적용시켜봅니다. 다음 그림처럼 순서번호 허용치가 6일 경우에는 SR 딜레마가 발생하지 않는다는 것을 볼 수 있습니다.

![image](https://user-images.githubusercontent.com/57826388/87138449-6667ec80-c2d9-11ea-8c0a-cee1db42c391.png)

<br>

이번에는 순서번호 허용치를 6으로 늘리고 ACK 손실 시나리오를 적용시켜봅니다. 패킷 손실 시나리오와 마찬가지로 SR 딜레마가 발생하지 않습니다.

![image](https://user-images.githubusercontent.com/57826388/87138458-68ca4680-c2d9-11ea-95f3-107d385bfc9c.png)

<br>

## 결론

Selective Repeat 딜레마를 해결하기 위해서는 순서번호 허용치가 윈도우 사이즈보다 크면 된다는 것을 알 수 있었습니다. 하지만 단순히 사이즈만 크면 해결되는 것은 아닙니다. 윈도우 사이즈의 크기에 따라 어느 정도의 비율보다 커야 합니다. 그 비율로 정의한 순서번호 허용치 값의 범위는 다음과 같습니다.

- 순서번호 허용치 값 >= 2 * 윈도우 사이즈
  
위의 식과 같이 순서번호의 허용치 값을 윈도우 사이즈의 값에 따라 지정하면 Selective Repeat 딜레마를 해결할 수 있습니다.
